---
import fs from "node:fs";
import path from "node:path";

// Get images from public/showcase
const showcaseDir = path.join(process.cwd(), "public", "showcase");
let images: string[] = [];

try {
  images = fs
    .readdirSync(showcaseDir)
    .filter((file) => /\.(jpg|jpeg|png|webp|gif)$/i.test(file))
    .map((file) => `/showcase/${file}`);
} catch (error) {
  console.error("Error reading showcase directory:", error);
}
---

<div class="slideshow-container" data-images={JSON.stringify(images)}>
  <div class="slides-wrapper">
    <!-- Two buffers for smooth cross-fading: Current and Next -->
    <div class="slide current" id="slide-current"></div>
    <div class="slide next" id="slide-next"></div>
  </div>

  <div class="pagination-lines" id="pagination-container">
    <!-- Lines will be injected here via JS -->
  </div>
</div>

<style>
  .slideshow-container {
    position: relative;
    width: 640px; /* Increased size */
    height: 360px; /* 16:9 */
    border-radius: 16px;
    overflow: hidden;
    /* Subtle Border Stroke */
    box-shadow:
      0 0 0 1px rgba(255, 255, 255, 0.1),
      0 20px 40px -10px rgba(0, 0, 0, 0.5);
    background: #111;
  }

  /* Responsive sizing */
  @media (max-width: 768px) {
    .slideshow-container {
      width: 100%;
      height: auto;
      aspect-ratio: 16/9;
    }
  }

  .slides-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .slide {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-size: cover;
    background-position: center;
    transition: opacity 0.8s ease-in-out;
  }

  .slide.current {
    z-index: 1;
    opacity: 1;
  }

  .slide.next {
    z-index: 2;
    opacity: 0;
    pointer-events: none;
  }

  .slide.next.active {
    opacity: 1;
  }

  /* Pagination Lines */
  .pagination-lines {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    padding: 1.5rem; /* Increased padding */
    display: flex;
    gap: 4px; /* Gap between lines */
    z-index: 20; /* High Z-index */
    pointer-events: none; /* Let clicks pass through if needed */
  }

  .p-line {
    height: 4px; /* Slightly thicker */
    flex: 1; /* Distribute width equally */
    background: rgba(255, 255, 255, 0.3); /* Higher contrast */
    border-radius: 2px;
    transition: background-color 0.3s;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.8); /* Shadow for visibility */
  }

  .p-line.active {
    background: var(--accent, #ccff00);
    box-shadow: 0 0 10px rgba(204, 255, 0, 0.8);
    opacity: 1;
  }
</style>

<script>
  function initSlideshow() {
    const container = document.querySelector(".slideshow-container");
    if (!container) return;

    // Data
    const rawImages = container.getAttribute("data-images");
    if (!rawImages) return;
    let allImages = JSON.parse(rawImages);

    // Shuffle
    for (let i = allImages.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [allImages[i], allImages[j]] = [allImages[j], allImages[i]];
    }

    const currentSlide = document.getElementById("slide-current");
    const nextSlide = document.getElementById("slide-next");
    const pagContainer = document.getElementById("pagination-container");

    if (!currentSlide || !nextSlide || !pagContainer) return;

    // --- SETUP PAGINATION ---
    // Inject lines based on image count
    // If too many images > 30, lines might be too small? 28 is fine.
    pagContainer.innerHTML = "";
    const lines = [];
    allImages.forEach((_, idx) => {
      const line = document.createElement("div");
      line.classList.add("p-line");
      if (idx === 0) line.classList.add("active");
      pagContainer.appendChild(line);
      lines.push(line);
    });

    let currentIndex = 0;

    // Initialize first image
    currentSlide.style.backgroundImage = `url('${allImages[0]}')`;
    // Preload second image into next slide just in case
    // (Actually we set next slide bg right before transition)

    function nextCycle() {
      const nextIndex = (currentIndex + 1) % allImages.length;
      const nextImg = allImages[nextIndex];

      // 1. Prepare Next Slide
      nextSlide.style.backgroundImage = `url('${nextImg}')`;

      // 2. Fade In Next Slide
      // Force reflow/wait a tick? Usually not needed if opacity was 0
      requestAnimationFrame(() => {
        nextSlide.classList.add("active");
      });

      // 3. Update Pagination immediately or after transition?
      // Usually immediately looks more responsive.
      lines[currentIndex].classList.remove("active");
      lines[nextIndex].classList.add("active");

      // 4. After Transition (0.8s), swap and reset
      setTimeout(() => {
        // "Next" is now fully visible and covering "Current"
        // Make "Current" show the new image (hidden behind Next)
        currentSlide.style.backgroundImage = `url('${nextImg}')`;

        // Turn off "Next" (it fades out? No, we simply remove active class BUT we need to ensure it doesn't flash)
        // If we remove .active from .next, it goes back to opacity 0.
        // Since .current is now the same image effectively behind it, the user sees no change.
        // However, .next has transition usually. If we remove opacity, it will fade out revealing .current.
        // Since .current is identical, it's a perfect cross-fade into self? No visually nothing happens.

        // Perfect Swap:
        // 1. Update current to new image
        // 2. Remove 'active' from next (it starts fading to 0).
        // Visually: Top layer fades out, revealing identical Bottom layer. Zero visual difference.
        // Ready for next sequence.

        nextSlide.classList.remove("active"); // Fades back to 0

        currentIndex = nextIndex;
      }, 800); // Wait for CSS transition time
    }

    setInterval(nextCycle, 3500);
  }

  initSlideshow();
  document.addEventListener("astro:page-load", initSlideshow);
</script>
